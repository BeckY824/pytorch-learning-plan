🧪 PyTorch 数据操作自检问卷（对应《动手学深度学习》第 2.1 节）

📘 一、基础概念题（填空 / 选择）
1.	张量（Tensor）是 __向量__ 的通用表示，在 PyTorch 中可以通过 torch.tensor(...) 创建。
2.	使用 reshape 改变张量形状时，其本质操作是否是复制数据？（True / False）True
3.	PyTorch 中创建均匀分布 0-7 的三维张量的代码是：
P = torch.arange(8).reshape(2,2,2)
4.	张量广播机制要求参与计算的两个张量维度满足什么条件？B
A. 必须完全一致
B. 每个维度相等或其中一个为1
C. 都必须为二维
D. 无要求

🧪 二、代码填空题（基础操作）
5.	请补全代码，生成一个形状为 (2, 3) 的全为 7 的张量：
import torch
A = torch.full((2, 3), __idk__)
6.	张量切片：请补全以下代码，取出第二行第二列元素：
B = torch.tensor([[1, 2], [3, 4]])
elem = B[ _1_ , _1_ ]
7.	请写出将以下张量拉平成一维的代码：
C = torch.tensor([[1, 2], [3, 4]])
flat = ___C.flatten()___
8.	请写出如下广播操作的代码，并说明结果的形状：
a = torch.ones((2, 1))
b = torch.ones((1, 3))
c = a + b
# 结果形状是： _2x3_ 矩阵内都是为2的元素

🔍 三、判断与简答题
9.	判断：两个不同张量之间的数据赋值不会共享内存。 True / False 
False
10.	简答：你如何理解 PyTorch 中的 广播机制？请尽量用自己的话回答。
不同形状的矩阵，可以通过补齐缺失部分（复制行/列）的元素，进行计算。

💡 四、进阶编程题
11.	编写一个函数，接收任意两个张量并返回它们按元素相乘的结果（考虑广播）：
def elementwise_product(t1, t2):
    if t1.shape == t2.shape :
        return t1*t2
    else:
        判断row与column，然后进行复制。（完善？）

12.	模拟一个小实验：

	•	创建一个三维张量，形状为 (2, 3, 4)，元素从 0 开始连续；
	•	打印出第一个维度上第一个元素（即一个 3x4 的子张量）；
	•	然后将该子张量的值全部乘以 2，并重新赋值回原张量；
	•	最后输出整个张量。

    A = torch.arange(24).reshape((2,3,4))
    print(A[0,0,0])
    B = A[0,:,:] * 2
    A[0,:,:] = B
    print(A)